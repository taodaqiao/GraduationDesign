2018-10-29
大致看了下调试的流程，先实现附加调试，貌似创建调试也实现好了
仔细看了代码，VT-DEMO代码不用在插件运行，直接r0 line hook了，那么我只需要写一个r3的exe进行数据传输，再写r0的驱动就行了
先把符号大致写下,注意需要symsrv.dll  dbghelp.dll 第一次运行还要个symsrv.yes 让他下载


2018-10-30
今天先试试内核Inline hook一个函数，之前也没有inline hook过，来hook一次，然后r3走一次调试就知道怎么样了
暂时先搞内核pass pg， 居然有直接复制代码无法到达的错误。。 可以在记事本中复制一次解决，还有汇编编译不能跟cpp写成一样的名称，obj同名编译错误啦
死活一直蓝屏，
唉，卸载也有点问题，还是他妈蓝 回去睡觉了草




2018-10-31
原来最后是线程执行hook后，代理函数末尾的值还有有写进去。艹 
总之一定要保证在hook的时候跳转和执行流程中各个变量都是可用的
改好了，用比较好的方式重写了一遍



2018-11-1
大致理清了，内核操作链表的线程同步问题需要特别注意。源码中debtool是调试器进程
大致写了proxyNtDebugActiveProcess

2018-11-2
调试端口保存的是指向调试对象的指针，


2018-11-5
创建对象成功，注意这里反调试也可以便利ObjTypeIndextable了
ObGetObjectType就是从对象中寻找到这个对象表中的对象，
那么可能被动手：
1.类型表被动手，创建的对象都没有调试权限
2.如果创建的是一个新的对象，只要不是原始的调试对象，那么他不知道这是什么对象，也只能抹掉validmask,但貌似他也只会抹掉DebugObject


2018-11-6
全部建好了，但是附加貌似什么信息都没拿到，唉，不知道又要调试多久，

2018-11-7
物理机能用了。但是他妈的虚拟机都不能用

2018-11-8
虚拟机还是没有头绪，而且恢复钩子后一会电脑就蓝屏，说是还有什么东西没清理完就卸载了驱动

2018-11-9
昨天心态已经粉碎了，还好今天调整了下，已经开始重新走原始的调试流程了，炸在setdebugport上，不走系统原始的执行完就蓝屏

2018-11-10
蓝屏是因为ethread结构不对，也只需要改ethread结构

2018-11-12
先搞定object，然后搭建双机环境调试swapcontex, 直接在虚拟机里面用pchunter反汇编看了下，确定swapcontext没有变化，可以直接恢复切换。
试试效果先

2018-11-13
绝望，连附加都不成功，唉 

2018-11-14
附加是成功的，但是创建线程失败了，强行跳过去拿不到相关信息

2018-11-15
在附加过程中，TP驱动不知道用了什么方法在附加到一半时强行使线程苏醒让附加失败了，如果暂停所有tp的内核线程，在创建进程时会卡死，
证明在tp开启时，创建任意一个进程都会经过他。
现在主要问题是
1.他是如何在我附加的时候，强行让进程苏醒导致附加失败的
2.恢复了swapcontext还是不能拿到任何正常的内存信息，该如何做才能在r3直接拿到他的内存信息。
（有让r3程序走派遣到驱动读，但是比较麻烦一点，且无法真正知道他所做的手脚）
草，貌似是因为人家直接把页表都清零了，你恢复了swapcontext页表还是错误的状态，
而驱动能读写的原因是当驱动attach上去时，tp帮你你恢复了真实的页表，
swapcontext的操作是有一个plm4e的表，他吧要处理的都记录在这个表里面，当你访问的时候，他先给一个假的cr3发生page fault到 idt 0xE，然后再这里面判断谁访问的
重点就是他怎么判断是谁访问的


2018-11-18
已经确定他就是抹掉pml4表了，pdpt表中的地址是一样的，但是前面的位不一样

2018-11-20
他不断抛出异常的问题还不知道怎么解决，还有在附加的时候他恢复进程导致附加失败的问题


2018-11-23
pml4恢复搞定，而且映射出来直接可写，还不用改了
自建断点链表来绕过抛异常的问题，测试中
调试器在中断到int3时，接下来要恢复继续执行时会先单步执行完之前的指令
现在的问题是要让所有调试器该处理的异常都给调试器，为此需要只要调试器每一种异常是怎么触发以及接受的，
先在只是弄清楚了int3

2018-11-23 
调试器在单步的时候，根本就没有设置DR寄存器

2018-11-25
开始编写处理int3和单步的代码，int3用链表保存，单步用一个地址表示应该就可以
调试器的流程是先把原值写回去，然后setthreadcontext单步
草 每个调试器写法不一样，

调试器每次触发单步都会执行完异常的指令后断在下一条指令，应该是cpu执行的

x32dbg:
F7:在单步遇到call的时候，F7继续设置TF单步，
F8:F8会在遇到call指令时在函数返回地址处下一个int3的断点，触发后就写回去，然后单步执行这条指令
int3触发，调试器会先恢复原有指令，然后设置一次单步异常（这个单步异常貌似不会处理），此时：
1. F9的话，将断点写回去
2. F8或者F7，再设置一个单步异常，收到异常后然后步过这条指令

ce:
单步会设置两次，估计有一次不会处理

两者不同的地方在于ce在触发的时候不会先将原始指令写回去，而x32dbg是在触发的时候就将原始指令写回去，之后的流程一样


2018-11-26
内核走回来的单步异常是下一条指令的地址，调试器在收到这个地址后的异常后才会把rip置过去

2018-11-27
第一个异常信息根本就没有发生，如果手动创建一个线程ok，问题是为什么没有触发成功 不知道。调试器已经做了异常过滤了，
现在只要能让调试器收到第一个异常信息，就Ok了

2018-12-4
最近事情发生得很多，自己心态有点崩不住了。加油吧


2018-12-10
只有一个线程在写dr  这个一般都能直接从上下文看到，其他都在读，而且值都是固定的。读的居然是单步异常我草。
eflags没有变化，还是只动了dr，但是dr确实没有执行硬断
会不会是我在get的时候他没变，然后再执行下面代码线程上下文已经发生变化了。可能当前线程要执行单步了，
但是又没有执行成功。
而且单步处理的过程都是在idt中就处理完了，forwardexception都收不到这些异常


2018-12-11
尝试在设置上下文前挂起线程，游戏不退出了，接来下测试修改dr看游戏的反应，
而且现在一个很有趣的现象，forwardexception都没有异常过来了



2018-12-12
心情真的很难受，我不知道怎么调节。
现在能set dr但是游戏就是没有断下来



2018-12-14
决定就好好搞游戏了，其他的当做爱好
朝着引擎进发！